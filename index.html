<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Prosty Projektant Domu 2D/3D Concept</title>
<style>
    body { 
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
        margin: 0; 
        display: flex; 
        height: 100vh; 
        overflow: hidden; 
        background: #1a1a1a; 
    }
    
    #sidebar { 
        width: 350px; /* Zwiƒôkszona szeroko≈õƒá */
        min-width: 350px;
        background: #2c3e50; 
        color: white; 
        padding: 20px; 
        display: flex; 
        flex-direction: column; 
        gap: 15px; 
        box-shadow: 4px 0 10px rgba(0,0,0,0.5);
        overflow-y: auto; /* W≈Çasny scroll panelu */
        z-index: 10;
    }

    /* Stylizacja paska przewijania dla sidebar */
    #sidebar::-webkit-scrollbar { width: 8px; }
    #sidebar::-webkit-scrollbar-track { background: #2c3e50; }
    #sidebar::-webkit-scrollbar-thumb { background: #456789; border-radius: 4px; }

    #canvas-container { 
        flex-grow: 1; 
        position: relative; 
        overflow: auto; 
        background: #fff; 
    }

    canvas { 
        display: block; 
        background-color: #ffffff;
        background-image: radial-gradient(#ccc 1px, transparent 1px); 
        background-size: 20px 20px; 
        transform-origin: 0 0;
    }

    .tool-group { 
        background: #34495e;
        padding: 15px; 
        border-radius: 8px;
        border-left: 4px solid #3498db;
    }

    h3 { margin: 0 0 10px 0; font-size: 13px; letter-spacing: 1px; text-transform: uppercase; color: #5dade2; }
    
    label { display: block; font-size: 12px; margin-bottom: 5px; color: #bdc3c7; }

    button { 
        width: 100%; 
        padding: 10px; 
        margin: 4px 0; 
        cursor: pointer; 
        border: none; 
        border-radius: 4px; 
        background: #2c3e50; 
        color: white; 
        font-weight: bold;
        transition: all 0.2s; 
    }
    button:hover { background: #3498db; transform: translateY(-1px); }
    button.active { background: #e74c3c; box-shadow: inset 0 0 10px rgba(0,0,0,0.3); }

    input, select { 
        width: 100%; 
        padding: 8px; 
        margin-bottom: 12px; 
        border-radius: 4px; 
        border: 1px solid #1a1a1a; 
        background: #ecf0f1;
        font-size: 14px;
    }

    #status { 
        position: fixed; 
        bottom: 20px; 
        left: 400px; 
        background: rgba(0,0,0,0.8); 
        color: #fff;
        padding: 8px 15px; 
        border-radius: 20px; 
        font-size: 13px; 
        pointer-events: none;
        box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }
</style>

</head>
<body>

<div id="sidebar">
    <h2>Projektant 2D</h2>
    
    <div class="tool-group">
        <h3>1. Wybierz Warstwƒô</h3>
        <select id="layerSelect">
            <option value="wall">Konstrukcja (≈öciany)</option>
            <option value="water">Woda / Kanalizacja (Niebieski)</option>
            <option value="elec">Elektryka (≈ª√≥≈Çty)</option>
            <option value="vent">Wentylacja (Zielony)</option>
        </select>
		<hr style="margin:8px 0; border-color:#555;">
        <label>Poka≈º warstwƒô</label>
		<div style="display:flex; flex-direction:row; gap:4px; font-size:12px;">
			<label style="display:flex; flex-direction:column; align-items:center; gap:6px; margin:0;">
				≈öciany <input type="checkbox" id="vis-wall" checked> 
			</label>
			<label style="display:flex; flex-direction:column; align-items:center; gap:6px; margin:0;">
				Woda/Kan <input type="checkbox" id="vis-water" checked> 
			</label>
			<label style="display:flex; flex-direction:column; align-items:center; gap:6px; margin:0;">
				Elektryka <input type="checkbox" id="vis-elec" checked> 
			</label>
			<label style="display:flex; flex-direction:column; align-items:center; gap:6px; margin:0;">
				Wentylacja <input type="checkbox" id="vis-vent" checked> 
			</label>
			<label style="display:flex; flex-direction:column; align-items:center; gap:6px; margin:0;">
				Obrazy <input type="checkbox" id="vis-images" checked> 
			</label>
		</div>
    </div>

    <div class="tool-group">
        <h3>2. Parametry Obiektu</h3>
        <label>Grubo≈õƒá/≈örednica [cm]:</label>
        <input type="number" id="thickness" value="10">
    </div>

    <div class="tool-group">
        <h3>3. Akcje i Pliki</h3>
        <button id="btnLine" class="active">Rysuj Liniƒô (Klik -> Klik)</button>
        <button id="btnDuplicate" style="background:#D0F0C0;color:#333333">üëØDuplikuj element</button>
		<button id="btnAddImage" style="background:#8e44ad;">üñºÔ∏è Dodaj obraz</button>
		<input type="file" id="imageInput" accept="image/*" style="display:none">
        <button id="btnSave" style="background: #27ae60;">üíæ Zapisz do pliku .json</button>
        <button id="btnLoad" style="background: #2980b9;">üìÇ Wczytaj projekt</button>
        <input type="file" id="fileInput" style="display:none" accept=".json">
		<button id="btnUndo" style="background:#f39c12;">‚Ü© COFNIJ</button>
        <button id="btnClear">Wyczy≈õƒá Projekt</button>
    </div>
	<div class="tool-group">
		<h3>4. Widok</h3>
		<label>Skala (Zoom): <span id="zoomVal">100</span>%</label>
		<input type="range" id="zoomRange" min="10" max="400" value="100">
		<button id="btnResetView">Resetuj Widok</button>
	</div>
	<div class="tool-group">
		<h3>5. Edycja Elementu</h3>
		<button id="btnSelectMode">Tryb: SELEKCJA (S)</button>
		<div id="editPanel" style="display:none; margin-top:10px; border-top:1px solid #555; padding-top:10px;">
			<p style="font-size:12px; color:#aaa;">Edytuj zaznaczony:</p>
			<label>Nazwa elementu:</label>
			<input type="text" id="editName">
			
			<div style="display:grid; grid-template-columns: 1fr 1fr; gap: 5px;">
				<div>
					<label>Start X1 [cm]:</label>
					<input type="number" id="editX1">
				</div>
				<div>
					<label>Start Y1 [cm]:</label>
					<input type="number" id="editY1">
				</div>
				<div>
					<label>Koniec X2 [cm]:</label>
					<input type="number" id="editX2">
				</div>
				<div>
					<label>Koniec Y2 [cm]:</label>
					<input type="number" id="editY2">
				</div>
			</div>

			<label style="color:#f1c40f;">D≈Çugo≈õƒá ca≈Çkowita [cm]:</label>
			<input type="number" id="editLen">

			<div style="display:grid; grid-template-columns: 1fr 1fr; gap: 5px;">
				<div>
					<label>Z1 [cm]:</label>
					<input type="number" id="editZ1">
				</div>
				<div>
					<label>Z2 [cm]:</label>
					<input type="number" id="editZ2" disabled>
				</div>
			</div>

			<label style="color:#5dade2;">Wysoko≈õƒá elementu (ŒîZ) [cm]:</label>
			<input type="number" id="editHeight">

			<label>Grubo≈õƒá [cm]:</label>
			<input type="number" id="editT">

			<button id="btnUpdate" style="background:#27ae60;">ZASTOSUJ ZMIANY</button>
			<button id="btnDelete" style="background:#c0392b;">USU≈É (Del)</button>
		</div>
		<div id="imageEditPanel" style="display:none; margin-top:10px; border-top:1px solid #555; padding-top:10px;">
			<p style="font-size:12px; color:#aaa;">Edytuj obraz:</p>

			<label>Nazwa obrazu:</label>
			<input type="text" id="imgName">

			<label>X [cm]</label>
			<input type="number" id="imgX">

			<label>Y [cm]</label>
			<input type="number" id="imgY">

			<label>Z1 [cm]</label>
			<input type="number" id="imgZ1">

			<label>Z2 [cm]</label>
			<input type="number" id="imgZ2">

			<label>Szeroko≈õƒá [cm]</label>
			<input type="number" id="imgW">

			<label>Wysoko≈õƒá [cm]</label>
			<input type="number" id="imgH">

			<label>Obr√≥t [¬∞]</label>
			<input type="number" id="imgRot">

			<div style="display:flex; gap:5px;">
				<button id="btnFlipX">Odbicie X</button>
				<button id="btnFlipY">Odbicie Y</button>
			</div>

			<button id="btnImgUpdate" style="background:#27ae60;">ZASTOSUJ</button>
			<button id="btnDeleteImg" style="background:#c0392b;">USU≈É (Del)</button>
		</div>

	</div>
	<!-- ‚úÖ DODAJ: Sekcja zestawienia d≈Çugo≈õci -->
	<div class="tool-group">
		<h3>6. Zestawienie d≈Çugo≈õci</h3>
		<div id="summaryPanel" style="font-size:13px; line-height:1.6;">
			<div>≈öciany: <strong><span id="sum-wall">0</span></strong> cm</div>
			<div>Woda/Kan: <strong><span id="sum-water">0</span></strong> cm</div>
			<div>Elektryka: <strong><span id="sum-elec">0</span></strong> cm</div>
			<div>Wentylacja: <strong><span id="sum-vent">0</span></strong> cm</div>
		</div>
	</div>



    <div style="margin-top: auto; font-size: 11px; color: #bdc3c7;">
        * Skala: 1px = 1cm<br>
        * Lewy klik: rysowanie<br>
        * Prawy klik: usu≈Ñ ostatni
    </div>
</div>

<div id="canvas-container">
	<div id="input-overlay" style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); 
		background: rgba(44, 62, 80, 0.9); color: white; padding: 10px 20px; border-radius: 20px; 
		display: none; font-size: 18px; font-weight: bold; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 1000;">
		D≈Çugo≈õƒá: <span id="input-buffer"></span>
	</div>
    <canvas id="mainCanvas"></canvas>
    <div id="status">X: 0, Y: 0 | Z: 0 cm</div>
</div>
<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    const status = document.getElementById('status');

    let elements = [];
	let historyStack = [];
	let layerVisibility = {
		wall: true,
		water: true,
		elec: true,
		vent: true,
		images: true
	};
    let isDrawing = false;
    let startPoint = null;
    let mousePos = { x: 0, y: 0 };
    let isShiftPressed = false;
	let scale = 1.0;
	let measureMode = false;
	let measureBasePoint = null;
	let measureElement = null;
	let measureOrientation = "perp"; // "perp" albo "parallel
	let images = [];              // ‚úÖ przechowuje obrazy (base64)
	let selectedImage = null;     // ‚úÖ zaznaczony obraz
	let isDraggingImage = false;  // ‚úÖ drag obrazka
	let imageDragOffset = { x:0, y:0 };
	let isResizingImage = false;
	let resizeHandle = null; // 'br'
	let isRotatingImage = false;
    const zoomRange = document.getElementById('zoomRange');
    const zoomVal = document.getElementById('zoomVal');
	const imageEditPanel = document.getElementById('imageEditPanel');
	
	let inputBuffer = ""; // Bufor dla wpisywanej d≈Çugo≈õci
    const inputOverlay = document.getElementById('input-overlay');
    const inputBufferDisplay = document.getElementById('input-buffer');
	// ‚úÖ Automatyczne liczenie Z2 na podstawie Z1 + wysoko≈õƒá
	const editZ1 = document.getElementById('editZ1');
	const editZ2 = document.getElementById('editZ2');
	const editHeight = document.getElementById('editHeight');

	function saveHistory() {
		historyStack.push(JSON.stringify({
			elements: elements,
			images: images
		}));
		
		// ograniczenie historii do 50 krok√≥w (opcjonalnie)
		if (historyStack.length > 50) {
			historyStack.shift();
		}
	}

	function undoLastEdit() {
		console.log(historyStack);
		if (historyStack.length === 0) return;

		const prevState = JSON.parse(historyStack.pop());
		console.log(prevState);
		elements = prevState.elements || [];
		images = [];

		if (prevState.images) {
			prevState.images.forEach(imData => {
				const img = new Image();
				// img.onload = () => render();
				img.src = imData.base64;

				images.push({
					name: imData.name || "obraz",
					base64: imData.base64,
					img: img,                 // ‚úÖ odtworzony HTMLImageElement
					x: imData.x,
					y: imData.y,
					width: imData.width,
					height: imData.height,
					z1: imData.z1 ?? 0,
					z2: imData.z2 ?? 0,
					rotation: imData.rotation || 0,
					flipX: imData.flipX || 1,
					flipY: imData.flipY || 1
				});
			});
		}

		selectedElement = null;
		selectedImage = null;
		editPanel.style.display = 'none';
		imageEditPanel.style.display = 'none';

		render();
	}

	function updateZ2FromHeight() {
		const z1 = parseFloat(editZ1.value) || 0;
		const h = parseFloat(editHeight.value) || 0;
		editZ2.value = z1 + h;
	}

	// Gdy zmienia siƒô Z1 lub wysoko≈õƒá ‚Üí przelicz
	editZ1.addEventListener('input', updateZ2FromHeight);
	editHeight.addEventListener('input', updateZ2FromHeight);

    canvas.width = 5000; 
    canvas.height = 5000;

    const colors = {
        wall: '#2c3e50',
        water: '#2980b9',
        elec: '#f1c40f',
        vent: '#27ae60'
    };
	
	let selectionMode = false;
    let selectedElement = null;

    // Prze≈ÇƒÖcznik trybu
    const btnSelectMode = document.getElementById('btnSelectMode');
    const editPanel = document.getElementById('editPanel');
	
	['wall','water','elec','vent','images'].forEach(layer => {
		document.getElementById('vis-' + layer).addEventListener('change', (e) => {
			layerVisibility[layer] = e.target.checked;
			render();
		});
	});

	function getDist(x1, y1, x2, y2) {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }
	
    btnSelectMode.onclick = () => {
        selectionMode = !selectionMode;
        isDrawing = false;
        startPoint = null;
        selectedElement = null;
        btnSelectMode.classList.toggle('active', selectionMode);
        btnSelectMode.innerText = selectionMode ? "Tryb: RYSOWANIE (S)" : "Tryb: SELEKCJA (S)";
        editPanel.style.display = 'none';		
		isDraggingElement = false;
        render();
    };

	document.getElementById('btnDuplicate').onclick = duplicateSelected;
	function duplicateSelected() {
		// ‚úÖ Duplikowanie elementu
		if (selectedElement) {
			saveHistory();

			const offset = 20; // przesuniƒôcie kopii

			const copy = {
				...selectedElement,
				x1: selectedElement.x1 + offset,
				y1: selectedElement.y1 + offset,
				x2: selectedElement.x2 + offset,
				y2: selectedElement.y2 + offset
			};

			elements.push(copy);
			selectedElement = copy;
			render();
		}

		// ‚úÖ Duplikowanie obrazu
		else if (selectedImage) {
			saveHistory();

			const offset = 20;

			const img = new Image();
			img.src = selectedImage.base64;

			const copy = {
				...selectedImage,
				img: img,
				x: selectedImage.x + offset,
				y: selectedImage.y + offset
			};

			images.push(copy);
			selectedImage = copy;
			render();
		}
	}

	document.getElementById('btnUndo').onclick = undoLastEdit;
	
	let isDraggingElement = false;
    let dragStartPos = { x: 0, y: 0 };
    let originalElPos = { x1: 0, y1: 0, x2: 0, y2: 0 };

    // --- Obs≈Çuga klawiszy strza≈Çek ---
    window.addEventListener('keydown', (e) => {
        if (selectedElement && !inputBuffer) { // Nie przesuwaj, gdy wpisujemy d≈Çugo≈õƒá
            const step = e.shiftKey ? 10 : 1;
            let moved = false;

            if (e.key === 'ArrowUp')    { selectedElement.y1 -= step; selectedElement.y2 -= step; moved = true; }
            if (e.key === 'ArrowDown')  { selectedElement.y1 += step; selectedElement.y2 += step; moved = true; }
            if (e.key === 'ArrowLeft')  { selectedElement.x1 -= step; selectedElement.x2 -= step; moved = true; }
            if (e.key === 'ArrowRight') { selectedElement.x1 += step; selectedElement.x2 += step; moved = true; }

            if (moved) {
                e.preventDefault();
                render();
            }
        }
		// Skr√≥ty klawiszowe (S dla selekcji, Delete dla usuwania)
        if (e.key.toLowerCase() === 's') btnSelectMode.onclick();
		
        // Obs≈Çuga Shift i ESC (zostaje z poprzedniej wersji)
        if (e.key === 'Shift') isShiftPressed = true;
        if (e.key === 'Escape') {
            isDrawing = false; startPoint = null; inputBuffer = "";
            inputOverlay.style.display = 'none'; render(); return;
        }
		// ‚úÖ ZMIANA orientacji miarki klawiszem R
		if (measureMode && e.key.toLowerCase() === 'q') {		
			measureOrientation = (measureOrientation === "perp") ? "parallel" : "perp";
		}
		if (selectedImage && e.key.toLowerCase() === 'x') {
			selectedImage.flipX *= -1;
			render();
		}

		if (selectedImage && e.key.toLowerCase() === 'y') {
			selectedImage.flipY *= -1;
			render();
		}
        // --- Logika wpisywania d≈Çugo≈õci ---
        if (isDrawing) {
            // Je≈õli u≈ºytkownik wpisuje cyfry, kropkƒô lub literƒô 'm'
            if (/^[0-9.m]$/.test(e.key)) {
                inputBuffer += e.key;
                inputOverlay.style.display = 'block';
                inputBufferDisplay.innerText = inputBuffer;
            } 
            
            // Usuwanie znaku
            else if (e.key === 'Backspace') {
                inputBuffer = inputBuffer.slice(0, -1);
                if (inputBuffer === "") inputOverlay.style.display = 'none';
                inputBufferDisplay.innerText = inputBuffer;
            }

            // Zatwierdzenie Enterem
            else if (e.key === 'Enter' && inputBuffer.length > 0) {
                processDirectInput();
            }
        }
    });

    // Funkcja sprawdzajƒÖca czy klikniƒôto w liniƒô (z tolerancjƒÖ 5px)
    function findElementAt(x, y) {
        return elements.find(el => {
			if (!layerVisibility[el.type]) return false;
            const L2 = Math.pow(el.x2 - el.x1, 2) + Math.pow(el.y2 - el.y1, 2);
            if (L2 === 0) {
				// traktuj jako punkt
				const dist = Math.sqrt(
					Math.pow(x - el.x1, 2) +
					Math.pow(y - el.y1, 2)
				);
				return dist < (el.t / 2 + 5);
			}
            const r = ((x - el.x1) * (el.x2 - el.x1) + (y - el.y1) * (el.y2 - el.y1)) / L2;
            if (r < 0 || r > 1) return false;
            const dist = Math.sqrt(
				Math.pow(x - (el.x1 + r * (el.x2 - el.x1)), 2) +
				Math.pow(y - (el.y1 + r * (el.y2 - el.y1)), 2)
			);
            return dist < (el.t / 2 + 5);
        });
    }
	document.getElementById('btnImgUpdate').onclick = () => {
		if (!selectedImage) return;

		selectedImage.x = parseFloat(document.getElementById('imgX').value);
		selectedImage.y = parseFloat(document.getElementById('imgY').value);
		selectedImage.width = parseFloat(document.getElementById('imgW').value);
		selectedImage.height = parseFloat(document.getElementById('imgH').value);
		selectedImage.z1 = parseFloat(document.getElementById('imgZ1').value) || 0;
		selectedImage.z2 = parseFloat(document.getElementById('imgZ2').value) || 0;
		selectedImage.name = document.getElementById('imgName').value;

		const deg = parseFloat(document.getElementById('imgRot').value);
		selectedImage.rotation = deg * Math.PI / 180;
		saveHistory();
		render();
	};
	document.getElementById('btnFlipX').onclick = () => {
		if (!selectedImage) return;
		selectedImage.flipX *= -1;
		render();
	};

	document.getElementById('btnFlipY').onclick = () => {
		if (!selectedImage) return;
		selectedImage.flipY *= -1;
		render();
	};
	
	function getMousePos(e) {
			const rect = canvas.getBoundingClientRect();
			// Uwzglƒôdniamy scroll kontenera i aktualnƒÖ skalƒô
			const x = Math.round((e.clientX - rect.left) / scale);
			const y = Math.round((e.clientY - rect.top) / scale);
			return { x, y };
		}
	function getEdgeBasePoint(el, clickX, clickY) {

		const dx = el.x2 - el.x1;
		const dy = el.y2 - el.y1;
		const len = Math.sqrt(dx*dx + dy*dy);
		if (len === 0) return null;

		const nx = -dy / len; // normalna
		const ny = dx / len;

		const offset = el.t / 2;

		// 4 mo≈ºliwe krawƒôdziowe punkty (2 ko≈Ñce x 2 strony)
		const candidates = [
			{ x: el.x1 + nx*offset, y: el.y1 + ny*offset },
			{ x: el.x1 - nx*offset, y: el.y1 - ny*offset },
			{ x: el.x2 + nx*offset, y: el.y2 + ny*offset },
			{ x: el.x2 - nx*offset, y: el.y2 - ny*offset },
		];

		// wybierz najbli≈ºszy do miejsca klikniƒôcia
		let best = candidates[0];
		let bestDist = getDist(clickX, clickY, best.x, best.y);

		candidates.forEach(p => {
			const d = getDist(clickX, clickY, p.x, p.y);
			if (d < bestDist) {
				best = p;
				bestDist = d;
			}
		});

		return best;
	}
	
	function getImageHandle(im, x, y) {
		const handleSize = 10 / scale;
		const right = im.x + im.width;
		const bottom = im.y + im.height;

		if (
			x >= right - handleSize &&
			x <= right + handleSize &&
			y >= bottom - handleSize &&
			y <= bottom + handleSize
		) {
			return "br"; // bottom-right
		}
		return null;
	}

	function processDirectInput() {
        let length = 0;
        if (inputBuffer.endsWith('m')) {
            length = parseFloat(inputBuffer.slice(0, -1)) * 100; // metry na cm
        } else {
            length = parseFloat(inputBuffer); // domy≈õlnie cm
        }

        if (!isNaN(length) && startPoint) {
            // Obliczamy wektor kierunku od punktu startowego do myszy
            const dx = mousePos.x - startPoint.x;
            const dy = mousePos.y - startPoint.y;
            const angle = Math.atan2(dy, dx);

            // Je≈õli Shift jest wci≈õniƒôty, wymu≈õ kƒÖty proste przy obliczaniu wektora
            let finalAngle = angle;
            if (isShiftPressed) {
                if (Math.abs(dx) > Math.abs(dy)) {
                    finalAngle = dx > 0 ? 0 : Math.PI;
                } else {
                    finalAngle = dy > 0 ? Math.PI/2 : -Math.PI/2;
                }
            }

            // Wyznaczamy nowy punkt ko≈Ñcowy na podstawie wpisanej d≈Çugo≈õci
            const newX = Math.round(startPoint.x + Math.cos(finalAngle) * length);
            const newY = Math.round(startPoint.y + Math.sin(finalAngle) * length);

            // Dodajemy element
			const layer = document.getElementById('layerSelect').value;
			elements.push({
				name: layer,
				type: layer,
				x1: startPoint.x, y1: startPoint.y,
				x2: newX, y2: newY,
				z1: 0,
				z2: 0,
				t: parseFloat(document.getElementById('thickness').value)
			});
			saveHistory();

            // Przesuwamy punkt startowy na koniec nowej linii (ciƒÖg≈Ço≈õƒá)
            startPoint = { x: newX, y: newY };
            mousePos = { x: newX, y: newY }; // "PrzyciƒÖgnij" kursor wizualnie
            
            // Czy≈õcimy bufor
            inputBuffer = "";
            inputOverlay.style.display = 'none';
            render();
        }
    }

    window.addEventListener('keyup', (e) => { 
        if (e.key === 'Shift') isShiftPressed = false; 
    });

    // --- Zaktualizowana logika MouseDown ---
    canvas.addEventListener('mousedown', (e) => {
		// Srodkowy przycisk nic nie r√≥b
		if (e.button === 1) {
			return;
		}
        // 1. Prawy przycisk myszy
		if (e.button === 2) {
			if (isDrawing) {
				isDrawing = false;
				startPoint = null;
			} 
			else if (!selectionMode) {   // <-- DODAƒÜ
				elements.pop();
			}
			render();
			return;
		}

        const pos = getMousePos(e);
		
		// ‚úÖ CTRL + klik = uruchom miarkƒô
		if (e.ctrlKey && !selectionMode) {

			const found = findElementAt(pos.x, pos.y);
			if (found) {

				measureMode = true;
				measureElement = found;
				measureBasePoint = getEdgeBasePoint(found, pos.x, pos.y);
				return;
			}
		}
        // 2. Tryb SELEKCJI i PRZESUWANIA
        if (selectionMode) {
			const foundImage = findImageAt(pos.x, pos.y);
            const found = findElementAt(pos.x, pos.y);
			if (foundImage) {
				saveHistory();
				const handle = getImageHandle(foundImage, pos.x, pos.y);

				if (handle) {
					selectedImage = foundImage;
					isResizingImage = true;
					resizeHandle = handle;
					return;
				}

				if (e.altKey) {  // ALT = obracanie
					selectedImage = foundImage;
					isRotatingImage = true;
					return;
				}

				selectedImage = foundImage;
				imageEditPanel.style.display = 'block';
                editPanel.style.display = 'none';

				document.getElementById('imgX').value = foundImage.x;
				document.getElementById('imgY').value = foundImage.y;
				document.getElementById('imgW').value = Math.round(foundImage.width);
				document.getElementById('imgH').value = Math.round(foundImage.height);
				document.getElementById('imgZ1').value = foundImage.z1 ?? 0;
				document.getElementById('imgZ2').value = foundImage.z2 ?? 0;
				document.getElementById('imgRot').value = Math.round(foundImage.rotation * 180 / Math.PI);
				document.getElementById('imgName').value = foundImage.name || "obraz";
				selectedElement = null;
				isDraggingImage = true;
				imageDragOffset.x = pos.x - foundImage.x;
				imageDragOffset.y = pos.y - foundImage.y;
				render();
				return;
			}
            else if (found) {
				saveHistory();
                selectedElement = found;
				selectedImage = null;
                editPanel.style.display = 'block';
				imageEditPanel.style.display = 'none';
                
                // Wype≈Çnianie p√≥l koordynatami
                document.getElementById('editX1').value = found.x1;
                document.getElementById('editY1').value = found.y1;
                document.getElementById('editX2').value = found.x2;
                document.getElementById('editY2').value = found.y2;
				document.getElementById('editZ1').value = found.z1 ?? found.z ?? 0;
				document.getElementById('editZ2').value = found.z2 ?? found.z ?? 0;
				document.getElementById('editHeight').value = (found.z2 ?? 0) - (found.z1 ?? 0);
                document.getElementById('editT').value = found.t;
				document.getElementById('editName').value = found.name || found.type;
                
                const len = getDist(found.x1, found.y1, found.x2, found.y2);
                document.getElementById('editLen').value = Math.round(len);
                
                isDraggingElement = true;
                dragStartPos = { ...pos };
                originalElPos = { x1: found.x1, y1: found.y1, x2: found.x2, y2: found.y2 };
            } else {
                selectedElement = null;
				selectedImage = null;
                editPanel.style.display = 'none';
				imageEditPanel.style.display = 'none';
            }
            render();
            return; // <--- DODANO: To jest kluczowe! Ko≈Ñczy funkcjƒô, aby NIE zaczƒô≈Ço rysowaƒá podczas edycji
        } 

        // 3. Tryb RYSOWANIA (wykona siƒô tylko je≈õli selectionMode == false) <--- ZMIANA: logika rysowania oddzielona
        if (!isDrawing || measureMode) {
            isDrawing = true;
            startPoint = { ...mousePos }; 
        } else {
			const layer = document.getElementById('layerSelect').value;
			saveHistory();
			elements.push({
				name: layer,
				type: layer,
				x1: startPoint.x,
				y1: startPoint.y,
				x2: mousePos.x,
				y2: mousePos.y,
				z1: 0,
				z2: 0,
				t: parseFloat(document.getElementById('thickness').value)
			});
            startPoint = { ...mousePos }; 
			saveHistory();
        }
        render();
    });
	
	document.getElementById('btnAddImage').onclick = () =>
    document.getElementById('imageInput').click();

	document.getElementById('imageInput').onchange = (e) => {
		const file = e.target.files[0];
		if (!file) return;
		saveHistory();
		const reader = new FileReader();
		reader.onload = (ev) => {
			const img = new Image();
			img.onload = () => {
				images.push({
					name: "obraz",
					base64: ev.target.result,
					img: img,
					x: mousePos.x,
					y: mousePos.y,
					width: img.width,
					height: img.height,
					z1: 0,
					z2: 0,
					rotation: 0,
					flipX: 1,
					flipY: 1
				});
				saveHistory();
				render();
			};
			img.src = ev.target.result;
		};
		reader.readAsDataURL(file);
	};
	
	function findImageAt(x, y) {
		if (!layerVisibility.images) return null;
		return images.find(im =>
			x >= im.x &&
			x <= im.x + im.width &&
			y >= im.y &&
			y <= im.y + im.height
		);
	}

	function deleteSelected() {
		if (selectedElement) {
			elements = elements.filter(el => el !== selectedElement);
			selectedElement = null;
		}
		if (selectedImage) {
			images = images.filter(im => im !== selectedImage);
			selectedImage = null;
		}
		editPanel.style.display = 'none';
		saveHistory();
		render();
	}
	
    document.getElementById('btnDelete').onclick = deleteSelected;
    document.getElementById('btnDeleteImg').onclick = deleteSelected;

    // Logika przycisku ZASTOSUJ ZMIANY
    document.getElementById('btnUpdate').onclick = () => {
        if (!selectedElement) return;
        selectedElement.x1 = parseInt(document.getElementById('editX1').value);
        selectedElement.y1 = parseInt(document.getElementById('editY1').value);
        selectedElement.x2 = parseInt(document.getElementById('editX2').value);
        selectedElement.y2 = parseInt(document.getElementById('editY2').value);
		selectedElement.z1 = parseFloat(editZ1.value) || 0;
		selectedElement.z2 = parseFloat(document.getElementById('editZ2').value);
        selectedElement.t = parseFloat(document.getElementById('editT').value);
		selectedElement.name = document.getElementById('editName').value;

		const height = parseFloat(editHeight.value) || 0;
		selectedElement.z2 = selectedElement.z1 + height;
        
        // Przeliczenie je≈õli zmieniono d≈Çugo≈õƒá rƒôcznie
        const newLen = parseFloat(document.getElementById('editLen').value);
        const currentLen = getDist(selectedElement.x1, selectedElement.y1, selectedElement.x2, selectedElement.y2);
        
        if (Math.abs(newLen - currentLen) > 0.5) {
             const angle = Math.atan2(selectedElement.y2 - selectedElement.y1, selectedElement.x2 - selectedElement.x1);
             selectedElement.x2 = Math.round(selectedElement.x1 + Math.cos(angle) * newLen);
             selectedElement.y2 = Math.round(selectedElement.y1 + Math.sin(angle) * newLen);
             document.getElementById('editX2').value = selectedElement.x2;
             document.getElementById('editY2').value = selectedElement.y2;
        }
		saveHistory();
        render();
    };
	
    // --- Zaktualizowana funkcja Statusu ---
    function updateStatus() {
        let mode = isDrawing ? "üöß RYSOWANIE (ESC by przerwaƒá)" : "üñ±Ô∏è TRYB WOLNY (Kliknij by zaczƒÖƒá)";
        let distStr = "";
        
        if (isDrawing && startPoint) {
            const d = Math.sqrt(Math.pow(mousePos.x - startPoint.x, 2) + Math.pow(mousePos.y - startPoint.y, 2));
            distStr = ` | D≈Çugo≈õƒá: ${(d/100).toFixed(2)} m (${Math.round(d)} cm)`;
        }
        
        status.innerHTML = `<strong>${mode}</strong> | X: ${mousePos.x}, Y: ${mousePos.y} ${distStr}`;
    }

	// --- Zaktualizowana logika MouseMove ---
	canvas.addEventListener('mousemove', (e) => {
		const pos = getMousePos(e);

		// Aktualizacja pozycji myszy z uwzglƒôdnieniem Shifta dla podglƒÖdu rysowania
		if (isDrawing && isShiftPressed && startPoint) {
			const dx = Math.abs(pos.x - startPoint.x);
			const dy = Math.abs(pos.y - startPoint.y);
			if (dx > dy) {
				mousePos.x = pos.x;
				mousePos.y = startPoint.y;
			} else {
				mousePos.x = startPoint.x;
				mousePos.y = pos.y;
			}
		} else {
			mousePos = pos;
		}

		// Logika przesuwania elementu <--- DODANO: obs≈Çuga drag & drop
		if (isDraggingElement && selectedElement && selectionMode) {
			const dx = mousePos.x - dragStartPos.x;
			const dy = mousePos.y - dragStartPos.y;
			
			selectedElement.x1 = originalElPos.x1 + dx;
			selectedElement.y1 = originalElPos.y1 + dy;
			selectedElement.x2 = originalElPos.x2 + dx;
			selectedElement.y2 = originalElPos.y2 + dy;

			// Aktualizacja p√≥l w panelu edycji na ≈ºywo podczas przesuwania <--- DODANO
			document.getElementById('editX1').value = selectedElement.x1;
			document.getElementById('editY1').value = selectedElement.y1;
			document.getElementById('editX2').value = selectedElement.x2;
			document.getElementById('editY2').value = selectedElement.y2;
		}
		if (isDraggingImage && selectedImage) {
			selectedImage.x = mousePos.x - imageDragOffset.x;
			selectedImage.y = mousePos.y - imageDragOffset.y;
		}
		// ‚úÖ Resize
		if (isResizingImage && selectedImage) {

			let newW = Math.max(20, mousePos.x - selectedImage.x);
			let newH = Math.max(20, mousePos.y - selectedImage.y);

			if (isShiftPressed) {
				const ratio = selectedImage.img.width / selectedImage.img.height;
				newH = newW / ratio;
			}

			selectedImage.width = newW;
			selectedImage.height = newH;
		}

		// ‚úÖ Rotacja
		if (isRotatingImage && selectedImage) {
			const cx = selectedImage.x + selectedImage.width / 2;
			const cy = selectedImage.y + selectedImage.height / 2;
			const angle = Math.atan2(mousePos.y - cy, mousePos.x - cx);
			selectedImage.rotation = angle;
		}
		if (selectedImage && imageEditPanel.style.display === 'block') {
			document.getElementById('imgX').value = Math.round(selectedImage.x);
			document.getElementById('imgY').value = Math.round(selectedImage.y);
			document.getElementById('imgW').value = Math.round(selectedImage.width);
			document.getElementById('imgH').value = Math.round(selectedImage.height);
			document.getElementById('imgRot').value =
				Math.round(selectedImage.rotation * 180 / Math.PI);
		}
		updateStatus();
		// ‚úÖ aktualizacja punktu startowego z miarki
		if (measureMode && measureBasePoint) {

			let dx = mousePos.x - measureBasePoint.x;
			let dy = mousePos.y - measureBasePoint.y;

			if (measureOrientation === "perp") {

				const ex = measureElement.x2 - measureElement.x1;
				const ey = measureElement.y2 - measureElement.y1;
				const len = Math.sqrt(ex*ex + ey*ey);
				const nx = -ey / len;
				const ny = ex / len;

				const dist = dx*nx + dy*ny;

				startPoint = {
					x: Math.round(measureBasePoint.x + nx*dist),
					y: Math.round(measureBasePoint.y + ny*dist)
				};

			} else {

				const ex = measureElement.x2 - measureElement.x1;
				const ey = measureElement.y2 - measureElement.y1;
				const len = Math.sqrt(ex*ex + ey*ey);
				const ux = ex / len;
				const uy = ey / len;

				const dist = dx*ux + dy*uy;

				startPoint = {
					x: Math.round(measureBasePoint.x + ux*dist),
					y: Math.round(measureBasePoint.y + uy*dist)
				};
			}

			isDrawing = true;
		}
		render();
	});
    // --- Dodanie MouseUp ---
    window.addEventListener('mouseup', () => {
		if (isDraggingElement) {
			saveHistory(); // ‚úÖ zapis po zako≈Ñczeniu przesuwania
		}

		if (isDraggingImage || isResizingImage || isRotatingImage) {
			saveHistory(); // ‚úÖ zapis po zmianie obrazu
		}
        isDraggingElement = false; // <--- DODANO: zatrzymuje przesuwanie po puszczeniu myszki
		measureMode = false;
		measureBasePoint = null;
		measureElement = null;
		isDraggingImage = false;
		isResizingImage = false;
		isRotatingImage = false;
		resizeHandle = null;
    });
    // Obs≈Çuga Zoom suwakiem
    zoomRange.oninput = (e) => {
        scale = e.target.value / 100;
        zoomVal.innerText = e.target.value;
        canvas.style.transform = `scale(${scale})`;
        canvas.style.transformOrigin = "0 0";
    };

    // Obs≈Çuga Zoom k√≥≈Çkiem myszy
    container.addEventListener('wheel', (e) => {
        if (e.ctrlKey) { // Zoom tylko z CTRL, by nie psuƒá przewijania
            e.preventDefault();
            let newScale = scale + (e.deltaY > 0 ? -0.1 : 0.1);
            newScale = Math.min(Math.max(0.1, newScale), 5); // Limit 10% - 500%
            scale = newScale;
            zoomRange.value = Math.round(scale * 100);
            zoomVal.innerText = zoomRange.value;
            canvas.style.transform = `scale(${scale})`;
            canvas.style.transformOrigin = "0 0";
        }
    }, { passive: false });

    document.getElementById('btnResetView').onclick = () => {
        scale = 1.0;
        zoomRange.value = 100;
        zoomVal.innerText = 100;
        canvas.style.transform = `scale(1)`;
        container.scrollLeft = 0;
        container.scrollTop = 0;
    };

    // Zmodyfikowana funkcja renderowania (linie pomocnicze muszƒÖ byƒá rysowane w skali 1:1)
    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 1. Linie pomocnicze (Crosshair)
        ctx.beginPath();
        ctx.strokeStyle = "rgba(0, 0, 0, 0.15)";
        ctx.lineWidth = 1 / scale; // Sta≈Ça grubo≈õƒá linii bez wzglƒôdu na zoom
        ctx.moveTo(0, mousePos.y); ctx.lineTo(canvas.width, mousePos.y);
        ctx.moveTo(mousePos.x, 0); ctx.lineTo(mousePos.x, canvas.height);
        ctx.stroke();

		elements.forEach(el => {
			if (!layerVisibility[el.type]) return;
            ctx.beginPath();
            ctx.moveTo(el.x1, el.y1);
            ctx.lineTo(el.x2, el.y2);
            ctx.lineWidth = el.t;
            // Pod≈õwietlenie na czerwono je≈õli zaznaczony
            ctx.strokeStyle = (el === selectedElement) ? "#ff0000" : colors[el.type];
            ctx.lineCap = 'round';
            ctx.stroke();

            // Obramowanie dla zaznaczonego elementu
            if (el === selectedElement) {
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = el.t + 4;
                ctx.strokeStyle = "rgba(255,0,0,0.3)";
                ctx.stroke();
                ctx.setLineDash([]);
            }
        });
		
		// ‚úÖ Rysowanie obraz√≥w
		if (layerVisibility.images) {
			images.forEach(im => {

				ctx.save();

				const cx = im.x + im.width / 2;
				const cy = im.y + im.height / 2;

				ctx.translate(cx, cy);
				ctx.rotate(im.rotation);
				ctx.scale(im.flipX, im.flipY);

				ctx.drawImage(
					im.img,
					-im.width / 2,
					-im.height / 2,
					im.width,
					im.height
				);

				// ‚úÖ Ramka zaznaczenia
				if (im === selectedImage) {
					ctx.strokeStyle = "#ff00ff";
					ctx.lineWidth = 2 / scale;
					ctx.strokeRect(
						-im.width / 2,
						-im.height / 2,
						im.width,
						im.height
					);

					// ‚úÖ Uchwyt resize (prawy dolny)
					ctx.fillStyle = "#ff00ff";
					ctx.fillRect(
						(im.width / 2 - 6 / scale) * im.flipX, // Mno≈ºymy przez flipX
						(im.height / 2 - 6 / scale) * im.flipY, // Mno≈ºymy przez flipY
						(12 / scale) * im.flipX,                // Szeroko≈õƒá te≈º musi reagowaƒá na kierunek
						(12 / scale) * im.flipY                 // Wysoko≈õƒá te≈º musi reagowaƒá na kierunek
					);
				}

				ctx.restore();
			});
		}
		
		// ‚úÖ Rysowanie miarki
		if (measureMode && measureBasePoint && startPoint) {

			ctx.beginPath();
			ctx.strokeStyle = "#e67e22";
			ctx.lineWidth = 2 / scale;
			ctx.setLineDash([10,5]);
			ctx.moveTo(measureBasePoint.x, measureBasePoint.y);
			ctx.lineTo(startPoint.x, startPoint.y);
			ctx.stroke();
			ctx.setLineDash([]);

			const d = getDist(measureBasePoint.x, measureBasePoint.y, startPoint.x, startPoint.y);

			ctx.fillStyle = "#e67e22";
			ctx.font = `bold ${14/scale}px Arial`;
			ctx.fillText(
				`${Math.round(d)} cm`,
				startPoint.x + (10/scale),
				startPoint.y - (10/scale)
			);
		}

        // 3. PodglƒÖd aktywnego rysowania
        if (isDrawing && startPoint) {
            ctx.beginPath();
            ctx.lineWidth = document.getElementById('thickness').value;
            ctx.strokeStyle = colors[document.getElementById('layerSelect').value] + "88";
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.lineTo(mousePos.x, mousePos.y);
            ctx.stroke();

            // Tekst z d≈Çugo≈õciƒÖ (skalowany)
            const dist = Math.sqrt(Math.pow(mousePos.x - startPoint.x, 2) + Math.pow(mousePos.y - startPoint.y, 2));
            ctx.fillStyle = "#000";
            ctx.font = `bold ${14/scale}px Arial`;
            ctx.fillText(`${(dist/100).toFixed(2)} m`, mousePos.x + (10/scale), mousePos.y - (10/scale));
        }
		// ‚úÖ DODAJ NA KO≈ÉCU render()
		updateSummary();
    }

    // Blokada menu i obs≈Çuga plik√≥w (jak wcze≈õniej)
    canvas.oncontextmenu = (e) => e.preventDefault();
    document.getElementById('btnClear').onclick = () => { 
		if(confirm("Wyczy≈õciƒá?")) { 
			saveHistory();
			images = []; 
			elements = []; 
			isDrawing = false; 
			render(); 
		} 
	};
	document.getElementById('btnSave').onclick = () => {
		const data = {
			elements: elements.map(el => ({
				name: el.name,
				type: el.type,
				x1: el.x1,
				y1: el.y1,
				z1: el.z1 ?? el.z ?? 0,
				x2: el.x2,
				y2: el.y2,
				z2: el.z2 ?? el.z ?? 0,
				t: el.t
			})),
			images: images.map(im => ({
				name: im.name,
				base64: im.base64,
				x: im.x,
				y: im.y,
				width: im.width,
				height: im.height,
				z1: im.z1 ?? 0,
				z2: im.z2 ?? 0,
				rotation: im.rotation,
				flipX: im.flipX,
				flipY: im.flipY
			}))
		};

		const dataUri = 'data:application/json;charset=utf-8,'+
			encodeURIComponent(JSON.stringify(data));

		const link = document.createElement('a');
		link.setAttribute('href', dataUri);
		link.setAttribute('download', 'projekt.json');
		link.click();
	};
    document.getElementById('btnLoad').onclick = () => document.getElementById('fileInput').click();
    document.getElementById('fileInput').onchange = (e) => {
		const reader = new FileReader();
		reader.onload = (ev) => {
			const data = JSON.parse(ev.target.result);

			// ‚úÖ Obs≈Çuga starego formatu (tablica)
			if (Array.isArray(data)) {
				elements = data;
				images = [];
			} else {
				elements = (data.elements || []).map(el => ({
					name: el.name || el.type,
					type: el.type,
					x1: el.x1,
					y1: el.y1,
					z1: el.z1 ?? el.z ?? 0,
					x2: el.x2,
					y2: el.y2,
					z2: el.z2 ?? el.z ?? 0,
					t: el.t
				}));
				images = [];
				if (data.images) {
					data.images.forEach(imData => {
						const img = new Image();
						img.onload = () => render();
						img.src = imData.base64;
						images.push({
							name: imData.name || "obraz",
							base64: imData.base64,
							img: img,
							x: imData.x,
							y: imData.y,
							width: imData.width,
							height: imData.height,
							z1: imData.z1 ?? 0,
							z2: imData.z2 ?? 0,
							rotation: imData.rotation || 0,
							flipX: imData.flipX || 1,
							flipY: imData.flipY || 1
						});
					});
				}
			}

			render();
		};
		reader.readAsText(e.target.files[0]);
	};
	// ‚úÖ DODAJ: funkcja liczƒÖca zestawienie d≈Çugo≈õci warstw
	function updateSummary() {
		const summary = {
			wall: { xy: 0, z: 0, total3D: 0 },
			water: { xy: 0, z: 0, total3D: 0 },
			elec: { xy: 0, z: 0, total3D: 0 },
			vent: { xy: 0, z: 0, total3D: 0 }
		};

		elements.forEach(el => {

			const dx = el.x2 - el.x1;
			const dy = el.y2 - el.y1;
			const dz = (el.z2 ?? el.z ?? 0) - (el.z1 ?? el.z ?? 0);

			const lenXY = Math.sqrt(dx*dx + dy*dy);
			const lenZ = Math.abs(dz);
			const len3D = Math.sqrt(dx*dx + dy*dy + dz*dz);

			summary[el.type].xy += lenXY;
			summary[el.type].z += lenZ;
			summary[el.type].total3D += len3D;
		});

		document.getElementById('sum-wall').innerText =
			`${Math.round(summary.wall.xy)} cm | Z: ${Math.round(summary.wall.z)} cm`;

		document.getElementById('sum-water').innerText =
			`${Math.round(summary.water.xy)} cm | Z: ${Math.round(summary.water.z)} cm`;

		document.getElementById('sum-elec').innerText =
			`${Math.round(summary.elec.xy)} cm | Z: ${Math.round(summary.elec.z)} cm`;

		document.getElementById('sum-vent').innerText =
			`${Math.round(summary.vent.xy)} cm | Z: ${Math.round(summary.vent.z)} cm`;
	}
</script>


</body>
</html>
